<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mere Code - Comments: Why you should write your tests first</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/" rel="alternate"></link><link href="http://code.mumak.net/feeds/comment.why-you-should-write-your-tests-first.atom.xml" rel="self"></link><id>http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/</id><updated>2010-09-22T22:46:00+01:00</updated><entry><title>Posted by: glyph (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-3206176607002629967.md" rel="alternate"></link><updated>2010-09-08T20:19:00+01:00</updated><author><name>glyph (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-08:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;... and another thing.  &lt;/p&gt;
&lt;p&gt;There is one case where not writing tests first is actually a better
idea, I think.  &lt;/p&gt;
&lt;p&gt;If you have some code with a lot of dependencies and no test support for
those dependencies (where "test support" means mocks, fakes, stubs,
in-memory implementations, or what-have-you), sometimes TDD means that
you have to start off by writing a largeish pile of unmaintainable
one-off junk just to stub out enough to get a simple test running.  &lt;/p&gt;
&lt;p&gt;I go back and forth on this, but I am coming to be of the opinion that
having big piles of unmaintainable test stubs &lt;em&gt;can&lt;/em&gt; be a worse problem
than having poor coverage. The stubs and functionality and interfaces
can diverge from the "real" implementations, and inevitably you end up
having to maintain a couple dozen fake implementations of the
not-really-test-supported interfaces, each of which has its own quirks.
This can lead to lots of false failures, which leads to decreased trust
in the test suite, which is of course bad.  &lt;/p&gt;
&lt;p&gt;If you're adding functionality to a system, you can usually manage this
problem by implementing the new functionality itself in a corner, with
only the dependencies that it really needs, and keep the test
maintenance burden sane. Rather than try to make sure that the
integration code is properly TDD, the goal is then to just keep the
integration code (which glues your shiny new TDD-developed module into
the system) as small as possible.  &lt;/p&gt;
&lt;p&gt;This is really just a restatement of "minimize untestable code", but I
take issue with that phrasing, because it's defeatist (especially in a
nice, dynamic language like Python). &lt;em&gt;All&lt;/em&gt; code is testable: this
strategy should be a temporary measure as you work towards developing
&lt;em&gt;good&lt;/em&gt; test support for your "untestable" interfaces and thinning out
unnecessary coupling. I think that it may be worthwhile to do some
planning and architecture around your test development as well as your
main body of code.&lt;/p&gt;</summary></entry><entry><title>Posted by: doxxxicle (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-3507088317300413492.md" rel="alternate"></link><updated>2010-09-07T14:27:00+01:00</updated><author><name>doxxxicle (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-07:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;I tend to be a "code &amp;amp; cover" type, mostly because the environments and
systems I write for are hard to simulate in a test and I often am not
sure what I need to do beforehand or how to do it -- i.e. prototyping
work.  &lt;/p&gt;
&lt;p&gt;Not very good excuses, I know.&lt;/p&gt;</summary></entry><entry><title>Posted by: absoludity (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-351305329505201410.md" rel="alternate"></link><updated>2010-09-07T13:53:00+01:00</updated><author><name>absoludity (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-07:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;The point that I enjoy the most about writing tests first is that it
breaks the task down into a lot of mini-successes: write test, run code
to show failure, add functionality, run test, success! For me it makes
it a bit more like a game where you're always trying to reach the next
level which is just out of reach.  &lt;/p&gt;
&lt;p&gt;Without writing tests first, it's more like a long wait until a
(potentially) big success, followed by many small failure moments as you
start finding bugs.  &lt;/p&gt;
&lt;p&gt;But I agree with Martin... when I'm unsure about which way to go,
&lt;em&gt;sometimes&lt;/em&gt; a tracer bullet helps me see how I can test.&lt;/p&gt;</summary></entry><entry><title>Posted by: Julian (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-3694031723642678615.md" rel="alternate"></link><updated>2010-09-08T14:52:00+01:00</updated><author><name>Julian (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-08:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;The big exception to the rule for me is a prototype, which then turns
into something useful. There's no way I am going to write tests up front
for a prototype.&lt;/p&gt;</summary></entry><entry><title>Posted by: Martin (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-4204081253523828672.md" rel="alternate"></link><updated>2010-09-07T11:46:00+01:00</updated><author><name>Martin (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-07:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;I've been flip-flopping a lot on this. I probably do more TDD than not,
but there are still scenarios where I just can't start off with tests.
Usually, it's because I either don't understand the problem well enough
yet, or because the testing infrastructure work needed is pretty big,
and I can't bring myself to spending so much time upfront on it.&lt;/p&gt;</summary></entry><entry><title>Posted by: Kevin H (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-4783755865577412917.md" rel="alternate"></link><updated>2010-09-22T22:46:00+01:00</updated><author><name>Kevin H (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-22:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;I tend to sketch out a minimal "spike solution", then write some tests
for it, and then use TDD to add functionality and make sure corner cases
get handled.&lt;/p&gt;</summary></entry><entry><title>Posted by: glyph (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-5119528839421413108.md" rel="alternate"></link><updated>2010-09-08T19:57:00+01:00</updated><author><name>glyph (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-08:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;This seems like it could use a little expanding; it seems to be written
for an audience that mostly understands what you're talking about
already, and will just evoke familiar pangs rather than really educate.
&lt;em&gt;Why&lt;/em&gt; is code-and-cover dull? You write the same tests and code either
way, right? Why is it harder to get full coverage? You just write your
tests and then run your coverage tool, of course.  &lt;/p&gt;
&lt;p&gt;I think that there are a lot of folks out there who do code-and-cover
but don't really know why it's not as good as TDD. A more expansive post
would benefit them quite a bit.  &lt;/p&gt;
&lt;p&gt;(Of course, &lt;em&gt;I&lt;/em&gt; know the answers, as do many of your readers, but I'm
too lazy to write a good post in response, so I'm hoping you'll do it
for me ;-)).  &lt;/p&gt;
&lt;p&gt;For my part, I do sometimes have trouble getting tests first, mostly in
not-fully-covered code that has a big pile of existing dependencies that
don't have test mocks, and building out even the most trivial test
infrastructure would take substantially longer than just fixing a simple
bug. However, when I do get around to fixing it "for real", I try to
avoid the code-and-cover mistake of writing a test that passes first: I
cut the whole implementation into another file, write a test, and get it
to fail first, then start re-importing the smallest bits I need to get
my test passing. Once I'm in the TDD groove again, I will quite often
spot uncovered or buggy chunks of functionality and get them fixed
right.  &lt;/p&gt;
&lt;p&gt;The few times I have tried to just write tests for existing code without
modifying it so that it will fail, it's been a complete mess.&lt;/p&gt;</summary></entry><entry><title>Posted by: jml (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-625296451880378550.md" rel="alternate"></link><updated>2010-09-14T13:29:00+01:00</updated><author><name>jml (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-14:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;Thanks for the comments everyone.  &lt;/p&gt;
&lt;p&gt;Julian, if by prototype you mean "proof of concept", then I also often
don't do that TDD. What tends to happen with those is that the prototype
&lt;em&gt;becomes&lt;/em&gt; the tests. (After all, how did I know it worked?).  &lt;/p&gt;
&lt;p&gt;Glyph, I would love to write up a more detailed version of this post.
It's unlikely I'll have the time.  &lt;/p&gt;
&lt;p&gt;A thing that can help with untested mocks &amp;amp; stubs is "interface
verification tests": one set of tests that runs against the real thing
and against a more easily testable thing.&lt;/p&gt;</summary></entry><entry><title>Posted by: jkakar (noreply@blogger.com)</title><link href="http://code.mumak.net/2010/09/why-you-should-write-your-tests-first.html/#comment-973756273912646077.md" rel="alternate"></link><updated>2010-09-09T02:53:00+01:00</updated><author><name>jkakar (noreply@blogger.com)</name></author><id>tag:code.mumak.net,2010-09-09:2010/09/why-you-should-write-your-tests-first.html/</id><summary type="html">&lt;p&gt;Whether you do TDD or code-and-cover it's very important to make sure
your test fails when the code you think it is testing is broken (or
gone). Doing TDD ensures this fail-when-broken check happens for each
test. This validation can be performed with code-and-cover, but it is
much more tedious.  &lt;/p&gt;
&lt;p&gt;I prefer TDD but use code-and-cover when I really don't understand what
I need. In that case, the code-and-cover I do is to (1) spike until I
know what I want and then (2) comment out my code and TDD until it's all
uncommented and covered properly.&lt;/p&gt;</summary></entry></feed>